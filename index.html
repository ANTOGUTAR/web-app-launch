<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>
      Web App Launch Handler API
    </title>
    <script src="https://www.w3.org/Tools/respec/respec-w3c" class="remove"
    defer></script>
    <script class='remove'>
      var respecConfig = {
        specStatus: "unofficial",
        github: {
          repoURL: "WICG/sw-launch",
          branch: "main"
        },
        group: "webapps",
        editors: [{
          name: "Alan Cutter",
          company: "Google Inc.",
          companyURL: "https://google.com",
          w3cid: 110742
        }],
        xref: {
          specs: [
            "web-platform",
            "file-system-access",
            "mediaqueries",
            "service-workers",
            "html",
            "appmanifest",
            "infra"
          ]
        }
        // To add eventually:
        //  - mdn: true
        //  - caniuse: "web-app-launch-handler"
      };
    </script>
  </head>
  <body data-cite="Web-Share encoding">
    <section id="abstract">
      <p>
        This specification defines an API that allows web applications to
        configure the behaviour of app launches with respect to already open app
        instances. This API aims to cater to the needs of single instance web
        apps e.g. music players.
      </p>
    </section>
    <section id="sotd">
      <pre class="warning">
        WIP Notes

        Spec skeleton:
          Use case example with code:
            Music player.
          Extend manifest extension point:
            launch_handler field.
            inner route_to field:
              Define route_to values and their meanings.
          Define launch process:
            Define launch routing selection process:
          IDLs:
            LaunchParams IDL:
              Note extensibility design; for members other than targetURL at
              most one will not be undefined depending on the type of launch.
            LaunchQueue IDL.
              Note why not events.
            window.launchQueue IDL.

        Concepts to import:
          App windows.
            "display": "standalone" must use this concept.
              It lives in media queries lol:
                https://www.w3.org/TR/mediaqueries-5/#display-mode-standalone
          Client.
            route_to uses this name.
            Service worker APIs use this name.
              Better check the SW concept is compatible here.
                Oh no it might not be:
                  https://developer.mozilla.org/en-US/docs/Web/API/WindowClient
                    The WindowClient interface of the ServiceWorker API represents the scope of a service worker client that is a document in a browsing context, controlled by an active worker.
                  App windows don't have to be controlled by an active worker to be eligible for route_to.
                  "new-client" -> "new-non-browser-display-mode"??
                  Maybe define "app window" as any app instance that's not display: browser.
                Wait never mind.
                  WindowClient is a JS interface not a spec concept. As an interface being exposed via a SW API of course it has an active service worker.
                  The SW spec defines a service worker client as an environment: https://w3c.github.io/ServiceWorker/#dfn-service-worker-client
                  And an environment may not have an active service worker.
                We should probably target window clients: https://w3c.github.io/ServiceWorker/#dfn-window-client


      </pre>
    </section>
    <section>
      <h2>
        Prerequisites
      </h2>
      <p>
        In order to implement this API, a the user agent MUST support
        [[[appmanifest]]].
      </p>
    </section>
    <section class="informative" data-link-for="WebAppManifest">
      <h2>
        Usage Example
      </h2>
      <p>
        A music player app wants to direct app shortcut launches to an existing
        window without interrupting music playback. This music app would add a
        {{launch_handler}} entry to the [[[appmanifest]]], as shown:
      </p>
      <pre class="example json" title="manifest.webmanifest">
      {
        "name": "Music Player",
        "shortcuts": [{
          "name": "Now Playing",
          "url": "/"
        }, {
          "name": "Library",
          "url": "/library"
        }, {
          "name": "Favorites",
          "url": "/favorites"
        }, {
          "name": "Discover",
          "url": "/discover"
        }],
        "launch_handler": {
          "route_to": "existing-client-retain"
        }
      }
      </pre>
      <p>
        With the <a data-cite="LaunchHandler.route_to">route_to</a> parameter
        set to "existing-client-retain" causes app launches to bring existing
        app instances (if any) into focus without navigating them away from
        their current document.
      </p>
      <p>
        A {{LaunchParams}} will be enqueued on the {{window.launchQueue}} where
        the music player can read the {{targetURL}} in its {{LaunchConsumer}}
        and handle it in script e.g.:
      </p>
      <pre class="example javascript" title="page.js">
        window.launchQueue.addConsumer((launchParams) => {
          const url = launchParams.targetURL;
          // If the URL is to one of the app sections, updates the app view to
          // that section without interrupting currently playing music.
          if (maybeFocusAppSection(url)) {
            return;
          }
          location.href = url;
        });
      </pre>
      <p>
        A user, already using the music player app to listen to music,
        activating the "Library" app shortcut will trigger an app launch to
        /library which gets routed to the existing app instance, enqueued in the
        page's {{window.launchQueue}} which, through the assigned
        {{LaunchConsumer}}, brings the library section of the music player into
        focus without affecting the current music playback.
      </p>
    </section>
    <section data-link-for="WebAppManifest">
      <h2>
        Extension to the Web App Manifest
      </h2>
      <p>
        The following steps are added to the <a data-cite=
        "!appmanifest#dfn-extension-point">extension point</a> in the steps for
        <a data-cite="appmanifest#dfn-processing-a-manifest">processing a
        manifest</a>:
      </p>
      <ol>
        <li>Run the steps for [=processing the launch_handler member=]
        given [=ordered map=] |json:ordered map| and [=ordered map=]
        |manifest:ordered map|.
        </li>
      </ol>
      <section>
        <h3>
          `launch_handler` member
        </h3>
        <p>
          The steps for <dfn>processing the `launch_handler` member</dfn>, given
          [=ordered map=] |json:ordered map|, [=ordered map=]
          |manifest:ordered map|, are as follows:
        </p>
        <ol class="algorithm">
          <li>If |json|["launch_handler"] does not [=map/exist=], return.
          </li>
          <li>If the type of |json|["launch_handler"] is not [=ordered map=],
          return.
          </li>
          <li>Set |manifest|["launch_handler"] to a new [=ordered map=].
          </li>
          <li>[=Process the `route_to` member=] passing
          |json|["launch_handler"], |manifest|["launch_handler"].
          </li>
        </ol>
      </section>
      <section>
        <h3>
          [=route_to=] member
        </h3>
        <p>
          The <dfn data-dfn-for="manifest">route_to</dfn> member of the manifest is a [=string=] or list of [=strings=] that declares
          whether web app launches reuse existing app [=window clients=] if any exist and whether or not to navigate their browsing context to the launch's [=target URL=] according to a [=route to target=].
        </p>
        <p>
          User agents MAY support only a subset of the [=route to targets=] depending on the constraints of the platform (e.g. mobile devices may not support multiple app instances simultaneously).
        </p>
        <p>
          <p>
            The <dfn>route to targets</dfn> are as follows:
          </p>
          <dl>
            <dt>
              <dfn data-dfn-for="route to">auto</dfn>
            </dt>
            <dd>
              The user agent's default launch routing behaviour is used.
              <p class="note">
                The user agent is expected to decide what works best for the
                platform. E.g., on mobile devices that only support single app instances the user agent may
                use `existing-client-navigate`, while on desktop devices that support
                multiple windows the user agent may use `new-client` to avoid data loss.
              </p>
            </dd>
            <dt>
              <dfn data-dfn-for="route to">new-client</dfn>
            </dt>
            <dd>
              A new web app client is created to load the launch's target URL.
            </dd>
            <dt>
              <dfn data-dfn-for="route to">existing-client-navigate</dfn>
            </dt>
            <dd>
              If an existing web app client is open it is brought to focus and
              navigated to the launch's target URL. If there are no existing web
              app clients the [=route to/new-client=] behaviour is used instead.
            </dd>
            <dt>
              <dfn data-dfn-for="route to">existing-client-retain</dfn>
            </dt>
            <dd>
              If an existing web app client is open it is brought to focus but
              not navigated to the launch's target URL, instead the target URL
              is communicated via {{LaunchParams}} . If there are no existing
              web app clients the [=route to/new-client=] behaviour is used
              instead.
            </dd>
          </dl>
        </p>
        <p>
          To <dfn>process the `route_to` member</dfn>, given [=ordered
          map=] |json_launch_handler:ordered map|, [=ordered map=]
          |manifest_launch_handler:ordered map|, run the following:
        </p>
        <ol class="algorithm">
          <li>If |json_launch_handler|["route_to"] does not [=map/exist=],
          return.
          </li>
          <li>If the type of |json_launch_handler|["route_to"] is
          [=list=]:
            <ol class="algorithm">
              <li>[=list/For each=] |entry| of |json_launch_handler|["route_to"]:
                <ol class="algorithm">
                  <li>If the type of |entry| is not [=string=], continue.
                  </li>
                  <li>If |json_launch_handler|["route_to"] is supported by the user agent, set manifest_launch_handler["route_to"] to |entry| and return.
                  </li>
                </ol>
              </li>
            </ol>
          </li>
          <li>If the type of |json_launch_handler|["route_to"] is not [=string=], return.
          </li>
          <li>If |json_launch_handler|["route_to"] is supported by the user agent, set manifest_launch_handler["route_to"] to |json_launch_handler|["route_to"].
          </li>
        </ol>
        <p class="note">
          `route_to` accepts a list of strings as a future proofing mechanism. If a new [=route to target=] is added in the future but has not yet been implemented by all user agents, web developers can cater to the old user agents by providing fallback [=route to target=] values in a list format. User agents will use the first value that is valid to them.
        </p>
        <p class="note">
          For example: if "some-new-behaviour" is added in the future a site developer can specify "[=route to/existing-client-navigate=]" to be the fallback with the following:
        </p>
        <pre class="note json">
          {
            "launch_handler": {
              "route_to": ["some-new-behaviour", "existing-client-navigate"]
            }
          }
        </pre>
      </section>
    </section>
    <section>
      <h2>
        Handling Web App Launches
      </h2>
      <section>
        <h2>
          Launching a Web App
        </h2>
        <p>
          The steps to <dfn>launch a web app</dfn> are given by the following algorithm and takes a {{LaunchParams}} |params:LaunchParams|.
        </p>
        <ol class="algorithm">
          <li>If |params| is null, set |params| to a new {{LaunchParams}} with {{LaunchParams/targetURL}} set to [=manifest/start_url=].
          </li>
          <li>Set |client| to the result of running the steps to [=prepare a web app launch client=] passing [=manifest/route_to=] and |params|.{{LaunchParams/targetURL}}.
          </li>
          <li>Append |params| to the [=unconsumed launch params=] of the |client|'s document's {{Window.LaunchQueue}}.
          </li>
          <li>If the [=assigned launch consumer=] |consumer| is set:
            <ol>
              <li>[=list/For each=] |launch_params:LaunchParams| of [=unconsumed launch params=]:
                <ol>
                  <li>Invoke |consumer| with |launch_params|.
                  </li>
                </ol>
              </li>
              <li>Set [=unconsumed launch params=] to the empty list.
              </li>
            </ol>
          </li>
        </ol>
      </section>
      <section>
        <h2>
          Choosing a [=Web App Launch Client=]
        </h2>
        <p>
          A <dfn>web app launch client</dfn> is a [=service worker client/window client=] associated with the web app.
        </p>
        <p class="note">
          The exact form of this association is up to the user agent e.g. a dedicated app window separated in its UI presentation from general hyperlink browsing.
        </p>
        <p>
          To <dfn>prepare a web app launch client</dfn>, given |route to| and |target URL:URL|:
        </p>
        <ol class="algorithm">
          <li>
            <p>Switching on |route to|, run the following substeps:</p>
            <dl class="switch">
              <dt>[=route to/new-client=]</code>
              <dd>
                <ol class="algorithm">
                  <li>Let |client| be the result of <a href="https://html.spec.whatwg.org/multipage/browsers.html#creating-a-new-top-level-browsing-context">creating a new top-level browsing context</a> presented in accordance with [=manifest/display=].
                  </li>
                  <li>Run the steps to [=navigate=] |client| passing |target URL|.
                  </li>
                  <li>Return |client|.
                  </li>
                </ol>
              <dt>[=route to/existing-client-navigate=] or [=route to/existing-client-retain=]</code>
              <dd>
                <ol class="algorithm">
                  <li>If there is no [=service worker client/window client=] for the web app, return the result of the steps to [=prepare a web app launch client=] passing [=route to/new-client=] and |target URL|.
                  </li>
                  <li>Let |client| be a [=service worker client/window client=] for the web app, the exact selection algorithm is decided by the user agent.
                  </li>
                  <li>If |route to| is [=route to/existing-client-navigate=], run the steps to [=navigate=] |client| passing |target URL|.
                  </li>
                  <li>Return |client|.
                  </li>
                </ol>
              <dt>Otherwise</code>
              <dd>
                <ol class="algorithm">
                  <li>Let |route_to| be either [=route to/new-client=] or [=route to/existing-client-navigate=] according to the user agent's decision for which is most appropriate.
                  </li>
                  <li>Return the result of the steps to [=prepare a web app launch client=] passing |route to| and |target URL|.
                  </li>
                </ol>
              </dd>
            </dl>
          </li>
        </ol>
      </section>
    </section>
    <section>
      <h2>
        Script Interfaces to App Launches
      </h2>
      <section data-dfn-for="LaunchParams">
        <h3>
          <dfn>LaunchParams</dfn> interface
        </h3>
        <ul class="issue">
          <li>This has been copied directly from <a href="https://wicg.github.io/manifest-incubations/index.html#launch-queue-and-launch-params">Manifest Incubations</a> without modification, this launch_handler spec should be its replacement home.</li>
          <li>LaunchParams should be a dictionary.</li>
          <li>targetURL should not be nullable.</li>
          <li>files should be optional</li>
          <li>For members other than targetURL only one should be not undefined, indicating the type of launch.</li>
        </ul>
        <pre class="idl">
          [Exposed=Window] interface LaunchParams {
            readonly attribute DOMString? targetURL;
            readonly attribute FrozenArray&lt;FileSystemHandle&gt; files;
          };
        </pre>
        <p>
          {{LaunchParams/targetURL}} represents the [=URL=] of the launch which
          MUST be [=manifest/within scope=] of the application.
        </p>
        <p>
          For every |file handle:FileSystemHandle| in {{LaunchParams/files}},
          querying the file system permission with
          {{FileSystemPermissionDescriptor/mode}} set to
          {{FileSystemPermissionMode/"readwrite"}} MUST return
          {{PermissionState/"granted"}}.
        </p>
      </section>
      <section data-dfn-for="LaunchConsumer">
        <h3>
          <dfn>LaunchConsumer</dfn> function
        </h3>
        <pre class="idl">
          callback LaunchConsumer = any (LaunchParams params);
        </pre>
      </section>
      <section data-dfn-for="LaunchQueue">
        <h3>
          <dfn>LaunchQueue</dfn> interface
        </h3>
        <pre class="idl">
          partial interface Window {
            readonly attribute LaunchQueue launchQueue;
          };

          [Exposed=Window] interface LaunchQueue {
            undefined setConsumer(LaunchConsumer consumer);
          };
        </pre>
        <p>
          {{LaunchQueue}} has an <dfn>unconsumed launch params</dfn> which is a
          [=list=] of {{LaunchParams}} that is initially empty.
        </p>
        <p>
          {{LaunchQueue}} has an <dfn>assigned launch consumer</dfn> which is
          initially null.
        </p>
        <section>
          <h2>
            <dfn>setConsumer</dfn> method
          </h2>
          <p>
            The {{LaunchQueue/setConsumer(consumer)}} method steps are:
          </p>
          <ol class="algorithm">
            <li>Set the [=assigned launch consumer=] to |consumer|.
            </li>
            <li>[=list/For each=] |launch_params:LaunchParams| of [=unconsumed
            launch params=]:
              <ol>
                <li>Invoke |consumer| with |launch_params|.
                </li>
              </ol>
            </li>
            <li>Set [=unconsumed launch params=] to the empty [=list=].
            </li>
          </ol>
        </section>
        <p class="note">
          {{LaunchParams}} are passed to the document via a {{LaunchQueue}}
          instead of via events to avoid a race condition between a launch event
          firing and page scripts attaching the event listener. In contrast the
          {{LaunchQueue}} buffers all enqueued {{LaunchParams}} until a
          {{LaunchConsumer}} has been set.
        </p>
      </section>
    </section>
    <section class="informative" data-cite="secure-contexts">
      <h2>
        Accessibility
      </h2>
      <p>
        This specification has no known accessibility considerations.
      </p>
    </section>
    <section class="informative" data-cite="secure-contexts">
      <h2>
        Security and privacy considerations
      </h2>
      <ul>
        <li>Invoking a [=web share target=] means potentially sending
        private user data to a third-party website. Implementors are to take
        every precaution that the user understands which party the data is
        being sent to (<i>e.g.</i>, communicating the web share target's
        origin), before running the [=invocation=] algorithm.
        </li>
        <li>Of particular concern is spoofing: a web share target presenting
        itself as a different party (by setting its name and icon accordingly).
        </li>
        <li>The spoofing risk is heightened if web share targets are chosen
        from an online index, rather than a set of targets that the end user
        has explicitly installed or registered.
        </li>
        <li>The requirement that the web share target's origin be a
        [=potentially trustworthy origin=] is to prevent private user data from
        being transmitted to a party that does not control the origin in
        question, or in clear text over the network.
        </li>
        <li>A source site using Web Share API, and a receipient site using Web
        Share Target, could cooperate to join user ids. The source site could
        use `navigator.share(text: my_id_for_this_user)`, and the (user-chosen)
        recipient could use that information to join its own user ID with the
        source origin's user ID. Both sides of the transfer would need to write
        code to accomplish the transfer, and the user would need to pick the
        recipient.
        </li>
      </ul>
    </section>
    <section id="conformance"></section>
    <section class="appendix informative">
      <h2>
        Acknowledgments
      </h2>
      <p>
        Ty WIP.
      </p>
    </section>
  </body>
</html>