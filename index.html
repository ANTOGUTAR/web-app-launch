<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>
      Web App Launch Handler API
    </title>
    <script src="https://www.w3.org/Tools/respec/respec-w3c" class="remove"
    defer></script>
    <script class='remove'>
      var respecConfig = {
        specStatus: "unofficial",
        github: {
          repoURL: "WICG/sw-launch",
          branch: "main"
        },
        group: "webapps",
        editors: [{
          name: "Alan Cutter",
          company: "Google Inc.",
          companyURL: "https://google.com",
          w3cid: 110742
        }],
        xref: {
          specs: ["web-platform", "file-system-access"]
        }
        // To add eventually:
        //  - mdn: true
        //  - caniuse: "web-app-launch-handler"
      };
    </script>
  </head>
  <body data-cite="Web-Share encoding">
    <section id="abstract">
      <p>
        This specification defines an API that allows web applications to
        configure the behaviour of app launches with respect to already open app
        instances. This API aims to cater to the needs of single instance web
        apps e.g. music players.
      </p>
    </section>
    <section id="sotd">
      <pre class="warning">
        WIP Notes

        Spec skeleton:
          Use case example with code:
            Music player.
          Extend manifest extension point:
            launch_handler field.
            inner route_to field:
              Define route_to values and their meanings.
          Define launch process:
            Define launch routing selection process:
          IDLs:
            LaunchParams IDL:
              Note extensibility design; for members other than targetURL at
              most one will not be undefined depending on the type of launch.
            LaunchQueue IDL.
              Note why not events.
            window.launchQueue IDL.

        Concepts to import:
          App windows.
            "display": "standalone" must use this concept.
              It lives in media queries lol:
                https://www.w3.org/TR/mediaqueries-5/#display-mode-standalone
          Client.
            route_to uses this name.
            Service worker APIs use this name.
              Better check the SW concept is compatible here.
                Oh no it might not be:
                  https://developer.mozilla.org/en-US/docs/Web/API/WindowClient
                    The WindowClient interface of the ServiceWorker API represents the scope of a service worker client that is a document in a browsing context, controlled by an active worker.
                  App windows don't have to be controlled by an active worker to be eligible for route_to.
                  "new-client" -> "new-non-browser-display-mode"??
                  Maybe define "app window" as any app instance that's not display: browser.
                Wait never mind.
                  WindowClient is a JS interface not a spec concept. As an interface being exposed via a SW API of course it has an active service worker.
                  The SW spec defines a service worker client as an environment: https://w3c.github.io/ServiceWorker/#dfn-service-worker-client
                  And an environment may not have an active service worker.
                We should probably target window clients: https://w3c.github.io/ServiceWorker/#dfn-window-client


      </pre>
    </section>
    <section>
      <h2>
        Prerequisites
      </h2>
      <p>
        In order to implement this API, a the user agent MUST support
        [[[appmanifest]]] and MUST support multiple simultaneous app instances.
      </p>
    </section>
    <section class="informative" data-link-for="WebAppManifest">
      <h2>
        Usage Example
      </h2>
      <p>
        A music player app wants to direct app shortcut launches to an existing
        window without interrupting music playback. This music app would add a
        {{launch_handler}} entry to the [[[appmanifest]]], as shown:
      </p>
      <pre class="example json" title="manifest.webmanifest">
      {
        "name": "Music Player",
        "shortcuts": [{
          "name": "Now Playing",
          "url": "/"
        }, {
          "name": "Library",
          "url": "/library"
        }, {
          "name": "Favorites",
          "url": "/favorites"
        }, {
          "name": "Discover",
          "url": "/discover"
        }],
        "launch_handler": {
          "route_to": "existing-client-retain"
        }
      }
      </pre>
      <p>
        With the <a data-cite="LaunchHandler.route_to">route_to</a> parameter
        set to "existing-client-retain" causes app launches to bring existing
        app instances (if any) into focus without navigating them away from
        their current document.
      </p>
      <p>
        A {{LaunchParams}} will be enqueued on the {{window.launchQueue}} where
        the music player can read the {{targetURL}} in its {{LaunchConsumer}}
        and handle it in script e.g.:
      </p>
      <pre class="example javascript" title="page.js">
        window.launchQueue.addConsumer((launchParams) => {
          const url = launchParams.targetURL;
          // If the URL is to one of the app sections, updates the app view to
          // that section without interrupting currently playing music.
          if (maybeFocusAppSection(url)) {
            return;
          }
          location.href = url;
        });
      </pre>
      <p>
        A user, already using the music player app to listen to music,
        activating the "Library" app shortcut will trigger an app launch to
        /library which gets routed to the existing app instance, enqueued in the
        page's {{window.launchQueue}} which, through the assigned
        {{LaunchConsumer}}, brings the library section of the music player into
        focus without affecting the current music playback.
      </p>
    </section>
    <section data-link-for="WebAppManifest">
      <h2>
        Extension to the Web App Manifest
      </h2>
      <p>
        The following steps are added to the <a data-cite=
        "!appmanifest#dfn-extension-point">extension point</a> in the steps for
        <a data-cite="appmanifest#dfn-processing-a-manifest">processing a
        manifest</a>:
      </p>
      <ol>
        <li>Run the steps for <a>processing the <code>launch_handler</code> member</a>
        given [=ordered map=] |json:ordered map| and [=ordered map=]
        |manifest:ordered map|.
        </li>
      </ol>
      <section>
        <h3>
          `launch_handler` member
        </h3>
        <p>
          The steps for <dfn>processing the `launch_handler` member</dfn>, given
          [=ordered map=] |json:ordered map|, [=ordered map=]
          |manifest:ordered map|, are as follows:
        </p>
        <ol class="algorithm">
          <li>If |json|["launch_handler"] does not [=map/exist=], return.
          </li>
          <li>If the type of |json|["launch_handler"] is not [=ordered map=],
          return.
          </li>
          <li>Set |manifest|["launch_handler"] to a new [=ordered map=].
          </li>
          <li>[=Process the `route_to` member=] passing
          |json|["launch_handler"], |manifest|["launch_handler"].
          </li>
        </ol>
      </section>
      <section>
        <h3>
          `route_to` member
        </h3>
        <p>
          The `route_to` member of the manifest is a [=string=] or list of [=strings=] that declares
          whether web app launches reuse existing app [=window clients=] if any exist and whether or not to navigate their browsing context to the launch's [=target URL=] according to a [=route to target=].
        </p>
        <p>
          <p>
            The <dfn>route to targets</dfn> are as follows:
          </p>
          <dl>
            <dt>
              <dfn data-dfn-for="route to">auto</dfn>
            </dt>
            <dd>
              The user agent's default launch routing behaviour is used.
              <p class="note">
                The user agent is expected to decide what works best for the
                platform. E.g., mobile devices only support single windows and would
                use `existing-client-navigate`, while desktop devices support
                multiple windows and would use `new-client` to avoid data loss.
              </p>
            </dd>
            <dt>
              <dfn data-dfn-for="route to">new-client</dfn>
            </dt>
            <dd>
              A new web app client is created to load the launch's target URL.
            </dd>
            <dt>
              <dfn data-dfn-for="route to">existing-client-navigate</dfn>
            </dt>
            <dd>
              If an existing web app client is open it is brought to focus and
              navigated to the launch's target URL. If there are no existing web
              app clients the [=route to/new-client=] behaviour is used instead.
            </dd>
            <dt>
              <dfn data-dfn-for="route to">existing-client-retain</dfn>
            </dt>
            <dd>
              If an existing web app client is open it is brought to focus but
              not navigated to the launch's target URL, instead the target URL
              is communicated via {{LaunchParams}} . If there are no existing
              web app clients the [=route to/new-client=] behaviour is used instead.
            </dd>
          </dl>
          <p>
            The <dfn>route to targets list</dfn> is the list « "[=route to/auto=]", "[=route to/new-client=]", "[=route to/existing-client-navigate=]" , "[=route to/existing-client-retain=]" ».
          </p>
        </p>
        <p>
          To <dfn>process the `route_to` member</dfn>, given [=ordered
          map=] |json_launch_handler:ordered map|, [=ordered map=]
          |manifest_launch_handler:ordered map|, run the following:
        </p>
        <ol class="algorithm">
          <li>If |json_launch_handler|["route_to"] does not [=map/exist=],
          return.
          </li>
          <li>If the type of |json_launch_handler|["route_to"] is
          [=list=]:
            <ol class="algorithm">
              <li>[=list/For each=] |entry| of |json_launch_handler|["route_to"]:
                <ol class="algorithm">
                  <li>If the type of |entry| is not [=string=], continue.
                  </li>
                  <li>If [=route to targets list=] contains |json_launch_handler|["route_to"], set manifest_launch_handler["route_to"] to |entry| and return.
                  </li>
                </ol>
              </li>
            </ol>
          </li>
          <li>If the type of |json_launch_handler|["route_to"] is not [=string=], return.
          </li>
          <li>If [=route to targets list=] does not contain |json_launch_handler|["route_to"], return.
          </li>
          <li>Set manifest_launch_handler["route_to"] to |json_launch_handler|["route_to"].
          </li>
        </ol>
        <p class="note">
          `route_to` accepts a list of strings as a future proofing mechanism. If a new [=route to target=] is added in the future but has not yet been implemented by all user agents, web developers can cater to the old user agents by providing fallback [=route to target=] values.
        </p>
        <p class="note">
          For example: if "existing-client-marquee" is added in the future a site developer can fallback to "[=route to/existing-client-navigate=]" with the following:
        </p>
        <pre class="note json">
          {
            "launch_handler": {
              "route_to": ["existing-client-marquee", "existing-client-navigate"]
            }
          }
        </pre>
      </section>
    </section>
    <section>
      <h2>
        Handling Web App Launches
      </h2>
      <section>
        <h2>
          Choosing a Launch Client
        </h2>
        <p>
          A <dfn>web app client</dfn> is an instance of a web app that's not [=display mode=] [=browser=].
        </p>
        <p>
          The steps to <dfn>select a web app client for launch</dfn> are given
          by the following algorithm. The algorithm takes a |route to:DOMString| which is one of [=route to list=].
        </p>
        <ol class="algorithm">
          <li>If |route to| is "[=route to/new-client=],
          </li>
        </ol>
      </section>
      <p>
        The steps to <dfn>launch a web app</dfn> are given by the following
        algorithm. The algorithm takes {{LaunchParams}}
        |params:LaunchParams|.
      </p>
      <ol class="algorithm">
        <li>If |params| is null, set |params| to a new {{LaunchParams}} with
        {{LaunchParams/targetURL}} set to [=manifest/start_url=].
        </li>
        <li>Create a new top level browsing context and navigate it to
        |params.targetUrl|.
        </li>
        <li>Append |params| to the [=unconsumed launch params=] of the
        launched document's {{Window.LaunchQueue}}.
        </li>
        <li>If the [=assigned launch consumer=] |consumer| is set:
          <ol>
            <li>[=list/For each=] |launch_params:LaunchParams| of
            [=unconsumed launch params=]:
              <ol>
                <li>Invoke |consumer| with |launch_params|.
                </li>
              </ol>
            </li>
            <li>Set [=unconsumed launch params=] to the empty list.
            </li>
          </ol>
        </li>
      </ol>
    </section>
    <section>
      <h2>
        Script Interfaces to App Launches
      </h2>
      <section data-dfn-for="LaunchParams">
        <h3>
          <dfn>LaunchParams</dfn> interface
        </h3>
        <ul class="issue">
          <li>This has been copied directly from <a href="https://wicg.github.io/manifest-incubations/index.html#launch-queue-and-launch-params">Manifest Incubations</a> without modification, this launch_handler spec should be its replacement home.</li>
          <li>LaunchParams should be a dictionary.</li>
          <li>targetURL should not be nullable.</li>
          <li>files should be optional</li>
          <li>For members other than targetURL only one should be not undefined, indicating the type of launch.</li>
        </ul>
        <pre class="idl">
          [Exposed=Window] interface LaunchParams {
            readonly attribute DOMString? targetURL;
            readonly attribute FrozenArray&lt;FileSystemHandle&gt; files;
          };
        </pre>
        <p>
          {{LaunchParams/targetURL}} represents the [=URL=] of the launch which
          MUST be [=manifest/within scope=] of the application.
        </p>
        <p>
          For every |file handle:FileSystemHandle| in {{LaunchParams/files}},
          querying the file system permission with
          {{FileSystemPermissionDescriptor/mode}} set to
          {{FileSystemPermissionMode/"readwrite"}} MUST return
          {{PermissionState/"granted"}}.
        </p>
      </section>
      <section data-dfn-for="LaunchConsumer">
        <h3>
          <dfn>LaunchConsumer</dfn> function
        </h3>
        <pre class="idl">
          callback LaunchConsumer = any (LaunchParams params);
        </pre>
      </section>
      <section data-dfn-for="LaunchQueue">
        <h3>
          <dfn>LaunchQueue</dfn> interface
        </h3>
        <pre class="idl">
          partial interface Window {
            readonly attribute LaunchQueue launchQueue;
          };

          [Exposed=Window] interface LaunchQueue {
            undefined setConsumer(LaunchConsumer consumer);
          };
        </pre>
        <p>
          {{LaunchQueue}} has an <dfn>unconsumed launch params</dfn> which is a
          [=list=] of {{LaunchParams}} that is initially empty.
        </p>
        <p>
          {{LaunchQueue}} has an <dfn>assigned launch consumer</dfn> which is
          initially null.
        </p>
        <section>
          <h2>
            <dfn>setConsumer</dfn> method
          </h2>
          <p>
            The {{LaunchQueue/setConsumer(consumer)}} method steps are:
          </p>
          <ol class="algorithm">
            <li>Set the [=assigned launch consumer=] to |consumer|.
            </li>
            <li>[=list/For each=] |launch_params:LaunchParams| of [=unconsumed
            launch params=]:
              <ol>
                <li>Invoke |consumer| with |launch_params|.
                </li>
              </ol>
            </li>
            <li>Set [=unconsumed launch params=] to the empty [=list=].
            </li>
          </ol>
        </section>
        <p class="note">
          {{LaunchParams}} are passed to the document via a {{LaunchQueue}}
          instead of via events to avoid a race condition between a launch event
          firing and page scripts attaching the event listener. In contrast the
          {{LaunchQueue}} buffers all enqueued {{LaunchParams}} until a
          {{LaunchConsumer}} has been set.
        </p>
      </section>
    </section>
    <section class="informative" data-cite="secure-contexts">
      <h2>
        Accessibility
      </h2>
      <p>
        This specification has no known accessibility considerations.
      </p>
    </section>
    <section class="informative" data-cite="secure-contexts">
      <h2>
        Security and privacy considerations
      </h2>
      <ul>
        <li>Invoking a <a>web share target</a> means potentially sending
        private user data to a third-party website. Implementors are to take
        every precaution that the user understands which party the data is
        being sent to (<i>e.g.</i>, communicating the web share target's
        origin), before running the <a>invocation</a> algorithm.
        </li>
        <li>Of particular concern is spoofing: a web share target presenting
        itself as a different party (by setting its name and icon accordingly).
        </li>
        <li>The spoofing risk is heightened if web share targets are chosen
        from an online index, rather than a set of targets that the end user
        has explicitly installed or registered.
        </li>
        <li>The requirement that the web share target's origin be a
        [=potentially trustworthy origin=] is to prevent private user data from
        being transmitted to a party that does not control the origin in
        question, or in clear text over the network.
        </li>
        <li>A source site using Web Share API, and a receipient site using Web
        Share Target, could cooperate to join user ids. The source site could
        use `navigator.share(text: my_id_for_this_user)`, and the (user-chosen)
        recipient could use that information to join its own user ID with the
        source origin's user ID. Both sides of the transfer would need to write
        code to accomplish the transfer, and the user would need to pick the
        recipient.
        </li>
      </ul>
    </section>
    <section id="conformance"></section>
    <section class="appendix informative">
      <h2>
        Acknowledgments
      </h2>
      <p>
        Thanks to the [[[WEBINTENTS]]] team, who laid the groundwork for the
        web app interoperability use cases. In particular, <a href=
        "https://paul.kinlan.me/">Paul Kinlan</a>, who did a lot of early
        advocacy for Web Share and Web Share Target.
      </p>
      <p>
        Thanks to Connie Pyromallis, who wrote an early draft of this spec, and
        helped design and prototype the API.
      </p>
      <p>
        Thanks to Alex Russell and David Baron, for their feedback on early
        drafts of this spec.
      </p>
    </section>
  </body>
</html>